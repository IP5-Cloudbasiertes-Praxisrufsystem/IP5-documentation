
\subsection{Cloud Service}\label{subsec:cloud-service}

\subsubsection{Architektur}

Der Cloud Service wird in die zwei Domänen Notification und Configuration aufgeteilt.
Dabei ist die Domäne Notification für das Versenden von Benachrichtigungen
und die Domäne Configuration für die Verwaltung und Auswertung der Konfigurationen verantwortlich.
Zwischen den beiden Domänen besteht eine gerichtete Abhängigkeit.
Die Domäne Notification benötigt zum Versenden von Benachrichtigungen Informationen aus der Configuration Domäne.
Das Identifizieren der relevanten Empfänger geschieht in der Configuration Domäne.
Dementsprechend benötigt die Notification Domäne beim Versenden und die Information an welche Empfänger die Benachrichtigung versendet werden soll.
Als Identifikation ist hier der technische Identifikator des Clients beim Messaging Service ausreichend.

Durch die klare Trennung der Verantwortungsbereiche der beiden Domains, wäre es möglich diese in einzelne Microservices aufzuteilen.
Dies würde das Skalieren der Applikationen vereinfachen.
Die Aufteilung auf mehrere Microservices macht das System als ganzes aber direkt komplizierter.
Insbesondere Betrieb und Entwicklung wird aufwändiger, da diese Arbeiten nun über mehrere Applikationen verteilt sind.
Für den Umfang dieser Arbeit wird deshalb darauf verzichtet, den Cloud Service als echtes Micro Service System umzusetzen.
Der Cloud Service wird als eine einzelne Spring Boot Applikation umgesetzt.
Innerhalb dieser Applikation sollen die Domänen Configuration und Notification allerdings, wo immer mit vertretbarem Aufwand möglich, getrennt bleiben.
Abhängigkeiten zwischen den beiden Domänen sind zu vermeiden.
An den Stellen wo Informationen aus der anderen Domäne nötig sind, sollen diese über ein Rest Interface abgefragt werden.
So kann die Applikation in Zukunft einfach und auf die tatsächlichen Bedürfnisse zugeschnitten in mehrere Microservices aufgeteilt werden.

Um einfache Erweiterbarkeit zu gewährleisten, wird der Cloud Service wird nach dem Prinzip von Onion Architecture aufgebaut.

\begin{figure}[h]
    \centering
    \begin{minipage}[b]{0.5\textwidth}
        \includegraphics[width=\textwidth]{graphics/clean-architecture}
        \caption{Clean Architecture}
    \end{minipage}
\end{figure}

In Onion Architecture wird die Applikation in Layern von der Domäne im Zentrum bis hin zur Infrastruktur an den äusseren Enden definiert.
Im Wesentlichen gibt es die folgenden Layers\cite{medium-onion}.

\textbf{Domain Model}
Im Zentrum des Modells steht die Domain selbst.
Der Domain Layer darf nur Dependencies auf sich selbst haben.
Abhängigkeiten aus anderen Layers sind um jeden Preis zu vermeiden.
Abhängigkeiten aus äusseren Layer auf den Domain Layer sind hingegen immer erlaubt.

\textbf{Domain Services}
Bieten die fachliche Logik und Verhaltensweise des Domain Model Layers an.

\textbf{Application Services}
Bildet die Brücke zwischen externer Infrastruktur und den DomainServices.
Dies beinhaltet Repository Services und Rest Controllers.

\textbf{Infrastructure}
Veranschaulicht die Infrastruktur ausserhalb des Systems.
Dies beinhaltet unter anderem Datenbanken, Messaging Services und Applikationen die auf Web APIs welche der Applikation zugreifen.

Da auf die Aufteilung in Microservices für den Rahmen dieses Projektes verzichtet wird, muss sich diese Architektur innerhalb des Services wiederspiegeln.
Dies soll durch die Aufteilung der Package Struktur geschehen.

\begin{figure}[h]
    \centering
    \begin{minipage}[b]{0.9\textwidth}

        \dirtree{%
        .1 ch.fhnw.ip5.praxiscloudservice.
        .2 api.
        .2 config.
        .2 domain.
        .2 persistence.
        .2 service.
        .2 web.
    }
    \caption{Package Struktur Cloud Service}\label{fig:packagescloudservice}
    \end{minipage}
\end{figure}

Im Zentrum steht das Package \textbf{domain}.
Es beinhaltet alle Domänenobjekte und stellt damit alleine den Domain Layer dar.

Das Package \textbf{api} definiert Interfaces für sämtliche Domain Services.
Es beinhaltet zudem Data Transition Objects (DTO), welche verwendet werden, um Daten nach aussen abzubilden.
sowie Exceptions welche für den Cloud Service definiert werden.

Das Package \textbf{persistence} definiert Services welche für Interaktion mit der Datenbank verwendet werden und gehört zum Application Services Layer.

Das Package \textbf{service} implementiert die Services, welche im api Package vorgegeben sind und entspricht dem Domain Service Layer.

Das Package \textbf{web} definiert die REST Endpunkte, welche die Applikation nach aussen anbietet,
sowie Clients die verwendet werden, um andere Systeme anzusprechen.
Es gehört zum Application Services Layer.

Das Package \textbf{config} beinhaltet technische Konfiguration der Applikation.

\clearpage

\subsubsection{Domäne Configuration}

\begin{figure}[h]
    \centering
    \begin{minipage}[b]{0.9\textwidth}
        \includegraphics[width=\textwidth]{graphics/Class_Configuration_Domain}
        \caption{Domänenmodell Configuration}
    \end{minipage}
\end{figure}

\textbf{PraxisUser}
Ein Benutzer für das Praxisrufsystem.
Jeder Benutzer kann die Rollen Admin oder User haben.
Ein Benutzer mit der Rolle Admin hat Recht die Konfiguration über das Admin UI zu verwalten.
Ein Benutzer mit der Rolle User ist berechtigt, den Mobile Client zu verwenden.

\textbf{Client}
Clients repräsentieren ein Endgeräte, auf welchen die Mobile Client Applikation läuft.

\textbf{Registration}
Die Registrierung eines Clients beinhaltet die technische Identifikation, mit der ein Client sich beim Messaging Service registriert hat.
Ein Client kann immer nur genau eine Registration haben.

\textbf{ClientConfiguration}
Stellt die Konfiguration eines Clients dar.
Die ClientConiguration beinhaltet die Informationen, welche Benachrichtigung ein Client versenden kann und welche Benachrichtigungen er empfangen soll.
Client und ClientConfiguration sind getrennt, damit Clients auch ohne Configuration erfasst werden können.
So kann der Administrator bereits Geräte im System erfassen ohne Sie vollständig zu konfigurieren.

\textbf{NotificationType}
Der NotificationType ist die Grundlage für Notifications die versendet werden.
Der NotificationType definiert Informationen für den Inhalt von Benachrichtigungen die versendet werden.
Er beinhaltet weiter Schlüssel für Texte die in einem Client angezeigt werden können.

\textbf{RuleParameters}
RuleParameters werden pro ClientConfiguration erfasst.
Die konfigurierten RuleParameters werden von der RulesEngine ausgewertet, um relevante Empfänger für eine Benachrichtigung zu finden.

\textbf{RuleType}
Der RuleType bestimmt wie die Parameter für eine Regel ausgewertet werden.
Für jeden Eintrag in der Tabelle RuleType muss es eine Implementierung des Interfaces RuleEvaluator geben, welche die RulesParameter Werte für den Regeltyp auswerten kann.

\begin{figure}[h]
    \centering
    \begin{minipage}[b]{0.9\textwidth}
        \includegraphics[width=\textwidth]{graphics/Class_Configuration_Services}
        \caption{Klassendiagramm Configuration Service Interfaces}
    \end{minipage}
\end{figure}

Die Configuration Domäne beinhaltet Services zum Lesen, Erstellen, Ändern und Löschen der Domänenobjekte.
Diese Verwaltungsfunktionen werden über eine RESTful Web-API exponiert. \footnote{Siehe Kapitel 5.3.4}
Der RegistrationService bietet dabei eine Ausnahme.
Er bietet die Funktionen, Registrierungen zu erfassen und aktualisieren.
Diese werden verwendet, wenn sich ein Mobile Client beim Cloud Service registriert.
Er bietet zudem die Möglichkeit die Identifikation (Token) aller relevanten Empfänger für eine gegebene Benachrichtigung zu finden.
Diese Auswertungen werden mithilfe der RulesEngine gemacht.
Die RulesEngine bewertet die erfassten RulesParameter mithilfe der RuleEvaluators und findet alle relevanten Einträge.

Die RulesEngine ermöglicht es, dem Cloud Service festzustellen, welche Benachrichtigungen an welche Clients versendet werden sollen.
Dazu bietet sie eine einzelne öffentliche Methode.
Diese nimmt eine Liste von Regelparametern (RulesParameters) und eine Notification entgegen.
Zurückgegeben wird ein Boolean Wert, der sagt, ob mindestens eine der übergebenen Regelparameter für die Benachrichtigung relevant ist.
Da jeder aktive Client eine ClientConfiguration definiert, die eine Liste an Regelparametern beinhaltet kann so mit der RulesEngine bewertet werden, ob ein bestimmter Client sich für eine Benachrichtigung interessiert.

\begin{figure}[h]
    \centering
    \begin{minipage}[b]{0.9\textwidth}
        \includegraphics[width=\textwidth]{graphics/Class_Configuration_RulesEngine}
        \caption{Klassendiagramm Rules Engine}
    \end{minipage}
\end{figure}

Die Auswertung der einzelnen Regelparameter innerhalb der RulesEngine wird an einzelne RuleEvaluatoren delegiert.
Umgesetzt wird dieses Konzept mit einem Strategy Pattern.\footnote{Referece Gamma Design Patterns}
RuleEvaluator definiert das Strategy Interface.
Der Zugriff auf die einzelnen Strategies innerhalb der RulesEngine wird über eine RuleEvaluatorFactory gelöst.
Diese Factory kennt alle existierenden RuleEvaluator Instanzen und bietet eine öffentliche Methode, über welche der RuleEvaluator für einen bestimmten Typ geladen werden kann.
Über die Dependency Injection des Spring Frameworks, kann diese RuleEvaluatorFactory einfach und erweiterbar implementiert werden:

\lstinputlisting[caption=RuleEvaluatorFactory.java,language=java,label={lst:RuleEvaluatorFactory.java}]{listings/RuleEvaluatorFactory.java}

Über den @Autowired Konstruktor nimmt die Factory eine Liste des Types RuleEvaluator entgegen.
Die Spring Dependency Injection wird hier automatisch alle verfügbaren RuleEvaluator Instanzen in einer Liste sammeln und als Konstruktorparameter entgegennehmen.
Da jeder RuleEvalutor eine Methode bietet, über die der relevante RuleType abgefragt werden kann, kann nun aus dieser Liste eine Map gebaut werden, die RuleTypes auf die relevanten RuleEvaluator Instanzen mapped.
Das Laden eines RuleEvaluators ahnand des RuleTypes kann nun über ein einfaches Lookup in der Map erfolgen.
Werden in der Zukunft weitere RuleTypes unterstützt, reicht es die entsprechende RuleEvaluatorFactory zu implementieren.
Der neue RuleEvaluator wird danach automatisch über dei RuleEvaluatorFactory verfügbar sein.
Anpassungen an der RulesEngine oder der RuleEvaluatorFactory sind nicht nötig.

\clearpage
\subsubsection{Domäne Notification}

\begin{figure}[h]
    \centering
    \begin{minipage}[b]{1.0\textwidth}
        \includegraphics[width=\textwidth]{graphics/Class_Notification_Domain}
        \caption{Domänenmodell Notification}
    \end{minipage}
\end{figure}

\textbf{PraxisNotification}
Jede Notification die der CloudService erhält wird bereits vor dem Versenden persistiert.
Dies ermöglicht einzelne Benachrichtigungen die nicht versendet werden konnten zu wiederholen.

\textbf{SendNotificationProcess}
Nach dem eine Benachrichtigung als PraxisNotification persistiert wurde, wird sie an die Empfänger versendet.
Dabei wird für jeden Empfänger ein SendNotificationProcess erstellt.
Dieser SendNotificationProcess beinhaltet eine Referenz auf die versendete Benachrichtigung und den Status des Sendeprozesses.
Dies ermöglicht es, eine Benachrichtigung nur für die Empfänger zu wiederholen, für die der Versand fehlgeschlagen ist.

\begin{figure}[h]
    \centering
    \begin{minipage}[b]{0.9\textwidth}
        \includegraphics[width=\textwidth]{graphics/Class_Notification_Services}
        \caption{Klassendiagramm Notification Service Interfaces}
    \end{minipage}
\end{figure}

Der \textbf{NotificationService} bietet Methoden, um eine Notifikation zu versenden und zu wiederholen.
Für das initiale Versenden werden die Informationen benötigt, um eine Notifikation zu erstellen und die Empfänger zu identifizieren.
Im Fall der Wiederholung werden diese Informationen nicht mehr benötigt.
Da die Notifikation und der Status des Versandprozesses beim ersten Versuch sie zu versenden persistiert wurde.

Der \textbf{NotificationSendProcessService} dient dazu Sendevorgänge zu erstellen und fehlgeschlagene Sendevorgänge zu finden.
Dies ermöglicht es, eine Notifikation im Fehlerfall zu wiederholen.

Der \textbf{NotificationTestService} dient zu Test und Administrationszwecken.
Er kann verwendet werden, um einem einzelnen Client eine Testnachricht zu senden oder allen registrierten Clients eine Nachricht zu schicken.
Als Benachrichtigung wird dabei immer eine vom Cloud Service definierte Benachrichtigung versendet, welche nur Platzhalterwerte beinhaltet.

\subsubsection{Laufzeitmodell}

Im Folgenden werden die Abläufe für die Registrierung von Mobile Clients sowie das Versenden und Empfangen von Benachrichtigungen im Detail definiert.

\subsubsection*{Client Registration}

Vorbedingung: Es wurde mindestens ein Client inklusive ClientConfiguration erfasst und dem Praxismitarbeiter zugewiesen.

\begin{figure}[h]
    \centering
    \begin{minipage}[b]{0.7\textwidth}
        \includegraphics[width=\textwidth]{graphics/Sequence_Notification_Register}
        \caption{Ablauf Registration}
    \end{minipage}
\end{figure}

In einem ersten Schritt muss sich der Praxismitarbeiter am Mobile Client anmelden.
Hat er gültige Benutzerdaten angegeben, werden Informationen zu allen verfügbaren Konfigurationen vom Cloud Service geladen und der Benutzer kann die gewünschte Konfiguration auswählen.
Dabei werden nur Name und Id der Konfigurationen geladen, damit nicht mehr Daten als nötig übertragen werden.
Der Benutzer wählt darauf die gewünschte Konfiguration.
Sobald die Konfiguration ausgewählt ist, werden alle dafür Konfigurierten NotificationTypes geladen und im UI die entsprechenden Buttons erstellt.
Direkt nach dem Laden der Konfiguration registriert sich der Mobile Client beim Messageing Service.
Als Antwort erhält er ein eindeutiges Token, welches verwendet werden kann, um an diesem Client Nachrichten zu senden.
Anschliessend registriert sich der Mobile Client mit dem erhaltenen Token und der ausgewählten Konfiguration beim Cloud Service.
In diesem Zustand ist der Client bei Messaging Service und Cloud Service registriert und bereit Benachrichtigungen zu empfangen.

\clearpage

\subsubsection*{Benachrichtigung versenden und empfangen}

Vorbedingung:
Konfiguration und Registrierung gemäss Abbildung 5.14 ist für zwei Clients ist abgeschlossen.
Konfiguration ist einer der Clients konfiguriert, Benachrichtigungen vom anderen Client zu empfangen.

\begin{figure}[h]
    \centering
    \begin{minipage}[b]{0.9\textwidth}
        \includegraphics[width=\textwidth]{graphics/Sequence_Notification_Send}
        \caption{Ablauf Benachrichtigung Senden und Empfangen}
    \end{minipage}
\end{figure}

Nachdem der Benutzer das Versenden einer Benachrichtigung auslöst, wird eine Anfrage an den NotificationController im Cloud Service gesendet.
Darin enthalten sind die Id des Senders sowie die Id des NotificationTypes.
Der NotificationController macht in der Folge eine Anfrage an den ConfigurationController, um alle relevanten Empfänger zu finden.
Im ConfigurationController werden die erfassten RuleParameters aller konfigurierten ClientConfigurations ausgewertet.
Darauf wird eine Liste der Registrations relevanter Empfänger zurückgegeben.
Sobald die Empfänger geladen sind, erstellt der NotificationController eine Benachrichtigung aus dem gegebenen NotificationType.
Diese Benachrichtigung wird als PraxisNotification persistiert und anschliessned
mit den geladenen Registrierungen an den Messaging Service gesendet, welcher die Zustellung an die entsprechenden Clients übernimmt.
Nach dem Übermitteln an den Messaging Service wird pro Empfänger ein NotificationSendProzess erstellt der den Status für diesen Empfänger dokumentiert.
Der NotificationController sender darauf eine Antwort zurück.
Diese Antwort beinhaltet die technische Id der versendeten Benachrichtigung und das Resultat ob die Benachrichtigung an alle Empfänger versendet werden konnte.
Ist dies nicht der Fall, wird der Retry-Process auf Client Seite gestartet.

Auf Empfängerseite wird, sobald die Benachrichtigung verarbeitet und angezeigt sobald die Zustellung durch den Messaging Service erfolgt ist.
Diese Zustellung erfolgt asynchron.
Kann der Sender nur informiert werden, wenn die Zustellung an den Messaging Service fehlgeschlagen ist.

\clearpage
\subsubsection*{Benachrichtigung wiederholen}

Vorbedingung:
Konfiguration und Registrierung gemäss Abbildung 5.14 ist für zwei Clients ist abgeschlossen.
Konfiguration ist einer der Clients konfiguriert, Benachrichtigungen vom anderen Client zu empfangen.
Es wurde eine Benachrichtigung gemäss Abbildung 5.15 versendet.
Dabei ist das Versenden an mindestens einen Client fehlgeschlagen und der Cloud Service hat ein negatives SendNotificationResult zurückgegeben.

Nach dem Erhalt des negativen Resultats zeigt der Mobile Client einen Dialog an.
Dieser Dialog informiert den Benutzer über den Fehler und fragt an, ob die fehlgeschlagenen Benachrichtigungen wiederholt werden sollen.
Bestätigt der Benutzer wird diese Anfrage, wird eine Anfrage an den NotificationController gesendet um das Versenden zu wiederholen.
Diese Anfrage beinhaltet die technische Id der fehlgeschlagenen Benachrichtigung.
NotificationController durchsucht die NotificationSendProcess Tabelle nach der gegebenen id und filtert auf fehlgeschlagene.
Anschliessend wird der SendProcess anhand der Tokens in dieser NotificationSendProcess Instanzen wiederholt.

\begin{figure}[h]
    \centering
    \begin{minipage}[b]{0.9\textwidth}
        \includegraphics[width=\textwidth]{graphics/Sequence_Notification_Retry}
        \caption{Ablauf Benachrichtigung Wiederholen}
    \end{minipage}
\end{figure}


\clearpage

\subsubsection{API}

Um die Verwaltung der Konfigurationen zu ermöglichen, bietet der Cloud Service eine REST-API an über die Konfigurationsobjekte verwaltet werden können.
Der Cloud Service bietet Verwaltungs APIs für die Folgenden Domänenobjekte:

\begin{table}[h]
    \centering
    \begin{tabular}{|l|p{13cm}|}
        \hline
        \textbf{Domänenobjekt} & \textbf{Entity Name} \\
        \hline
        Client         & /api/clients \\
        \hline
        Client Configuration         & /api/client-configurations \\
        \hline
        Notification Types         & /api/notification-types \\
        \hline
        Users         & /api/users \\
        \hline
    \end{tabular}\label{tab:adminapimethods}
\end{table}

Für jedes dieser Domänenobjekte ist ein dedizierter Endpoint definiert, der unter dem Subpfad /api/entity-name erreichbar ist.
Jeder dieser Kontroller bietet eine API zu Verwaltung dieses Domänenobjekts, welche dem folgenden Schema folgt:

\begin{tabular}{|p{7.3cm}|l|l|l|l|}
    \hline
    \textbf{Action} & \textbf{HTTP} & \textbf{Pfad} & \textbf{Body} & \textbf{Response} \\
    \hline
        Alle Elemente lesen         & GET & /api/entity-name & - & [EntityDto] \\
    \hline
        Einzelnes Element lesen         & GET & /api/entity-name/id & - & EntityDto \\
    \hline
        Neues Element erstellen         & POST & /api/entity-name  & EntityDto & EntityDto\\
    \hline
        Bestehendes Element ändern          & PUT & /api/entity-name  & EntityDto & EntityDto\\
    \hline
        Einzelnes Element löschen          & DELETE & /api/entity-name/id  & - & -  \\
    \hline
        Mehrere Elemente löschen          & DELETE & /api/entity-name/ids  & - & - \\
    \hline
\end{tabular}\label{tab:apimethods}

Eine Ausnahme, bildet hier das Domänenobjekt Registration.
Hier wird wird analog zum Domänenservice für Registrations\footnote{Siehe Kapitel 5.3.2} folgende API angeboten:

\begin{tabular}{|l|l|l|l|l|}
    \hline
    \textbf{Aktion} & \textbf{HTTP} & \textbf{Pfad} & \textbf{Body} & \textbf{Response} \\
    \hline
    Registrierung aktualisiern         & POST & /api/registrations/ & ClientId, Token & - \\
    \hline
    Registrierung entfernen         & DELETE & /api/registrations/ & ClientId & - \\
    \hline
    Relevante Registrierung finden         & POST & /api/registrations/tokens & NotificationDto & [RegistrationDto] \\
    \hline
\end{tabular}\label{tab:registrationsapimethods}

\subsubsection*{Benachrichtigungen}

Zum Versenden von Benachrichtigungen bietet der Cloud Service folgende Endpunkte an:

\begin{tabular}{|l|l|l|l|l|}
    \hline
    \textbf{Aktion} & \textbf{HTTP} & \textbf{Pfad} & \textbf{Body} & \textbf{Response} \\
    \hline
    Registrierung aktualisiern         & POST & /api/registrations/ & ClientId, Token & - \\
    \hline
    Registrierung entfernen         & DELETE & /api/registrations/ & ClientId & - \\
    \hline
    Relevante Registrierung finden         & POST & /api/registrations/tokens & NotificationDto & [RegistrationDto] \\
    \hline
\end{tabular}\label{tab:registrationsapimethodss}

\clearpage

\subsubsection*{Authentifizierung}
\begin{figure}[h]
    \centering
    \label{fig:authSequence}
    \includegraphics[width=0.5\textwidth]{graphics/Authentication-export}\caption[Authentifizierung-Sequenz]{Authentifizierung-Sequenz}
\end{figure}

\clearpage

