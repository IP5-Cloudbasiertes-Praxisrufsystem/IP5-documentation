\section{Konzept}\label{sec:konzept}
\subsection{Systemarchitektur}\label{subsec:systemarchitektur}
\subsubsection*{Überblick}

Das Cloudbasierte Praxisrufsystem wird in vier Komponenten unterteilt.
Abbildung 4.1 gibt einen Überblick über das System als ganzes:

\begin{figure}[h]
    \centering
    \begin{minipage}[b]{0.8\textwidth}
        \includegraphics[width=\textwidth]{graphics/IP5_POC_Cloud_Architecture}
        \caption{System}
    \end{minipage}
\end{figure}

Die Anforderungen U12 setzt voraus, dass die Kommunikation im Praxisrufsystem
zwischen mehreren Geräten erfolgen kann.

Die Anforderungen U06, U07 und U13 setzten voraus, dass die es eine zentrale Stelle gibt
die Konfigurationen zur Verfügung stellt und das Versenden von Notifikationen koordiniert.




Für das Cloudbasierte Praxisruf System sehen wir vier Komponenten vor:

\begin{itemize}
    \item Mobile Client
    \item Cloud Service
    \item Messaging Service
    \item Admin UI
\end{itemize}

\subsubsection*{Mobile Client}

\begin{itemize}
    \item Der Mobile Client implementiert die Anbindung an den Messaging Service.
    \item Als Reaktion auf eine Notification wird eine Rückmeldung im UI angezeigt.
    \item Als Reaktion auf eine Notification wird eine OS Push Notifikation gesendet.
    Das UI bietet einen Button der eine Anfrage an die REST Schnittstelle im Cloud Service sendet.
\end{itemize}


\subsubsection*{Cloud Service}

\begin{itemize}
    \item Responsibilities (Notification and Configuration)
    \item Microservice Granularity
\end{itemize}


\subsubsection*{Messaging Service}

\begin{itemize}
    \item Dies wird ein externer Service den wir in die Applikationen einbinden. Standard hierfür ist Firebase Notifications.
    \item Der Messaging Service nimmt Notifikationen vom Cloud Service entgegen und gibt diese an den Mobile Client wieder.
    \item Dafür müssen auf beiden Seiten Komponenten eingebaut werden, die mit dem Messaging Service kommunizieren.
\end{itemize}

\clearpage

\subsection{Mobile Client}\label{subsec:mobile-client}

\subsubsection{Framework Grundlagen}
NativeScript bietet eine Abstraktion zu den nativen Plattformen Android und IOS.
Die jeweilige NativeScript Runtime erlaubt es in Javascript (oder einem entsprechenden Application Framework) Code zu schreiben,
welcher direkt für die entsprechende native Umgebung kompiliert wird~\cite{ns-core-overview}.
\begin{figure}[h]
    \centering
    \label{fig:howNSWorks}
    \includegraphics[width=0.7\textwidth]{graphics/ns-common}\caption[NativeScript-Overview]{NativeScript-Overview}\textcopyright OpenJS Foundation
\end{figure}


Die Runtime agiert als Proxy zwischen Javascript und dem jeweiligen Ökosystem.
Im Falle von IOS bedeutet dies u.A. das für alle Objective-C types ein JavaScript Prototype angeboten wird.
Dies ermöglicht es direkt mit nativen Objekten zu interagieren.
Im Umkehrschluss findet eine Typenkonversion via Marshalling Service statt\cite{ns-ios-runtime}.

\subsubsection{Anwendung}
Wir verwenden NativeScript Core als Framework des Mobile-Clients.
In Kapitel~\emph{\nameref{subsec:mobile-client-eval}} gehen wir auf die weiteren verfügbaren Frameworks ein und erläutern, weshalb wir uns gegen sie entschieden haben.

Die Client-Applikation ist in Module unterteilt.
Ein Modul wird aus folgenden Komponenten definiert:
\begin{itemize}
    \item UI-Markup: Statische Darstellung in XML
    \item Backend: Verhalten und Dynamisierung in Javascript
    \item Styling: Layout und Styles in CSS
\end{itemize}

Ein minimales Modul kann alleine aus einer XML-Datei bestehen.
Die optionalen Javascript und CSS Dateien müssen denselben Namen haben wie die XML Datei, um vom Framework korrekt verknüpft zu werden.
Dateien mit anderen Namen werden grundsätzlich vom Framework ignoriert.
Natürlich steht es Frei dennoch solche Dateien anzulegen und deren Funktionen zu verwenden z.~B. als~\emph{\nameref{subsubsec:services}} oder als~\emph{\nameref{subsubsec:code-behind-komponenten}}.

Zur Veranschaulichung der möglichen Interaktionen gehen wir auf die relevanten Aspekte des Home-Screen Modules ein.

\subsubsection*{Page Module}

\dirtree{%
.1 app.
.2 home.
.3 home-page.xml.
.3 home-page.css.
.3 home-page.js.
.3 home-model.js.
}

\emph{\nameref{lst:home-page.xml}} deklariert die umgebenden Komponenten.
Diese Komponenten stellen je nach Typ diverse Properties und Events zur Verfügung.
Properties können entweder statisch befüllt oder aus dem Binding-Context geladen werden.
Den Events können Callback-Functions zugewiesen werden.
Es stehen alle Funktionen zur Verfügung, welche im Backendscript~\emph{\nameref{lst:home-page.js}} exportiert werden.

\lstinputlisting[caption=home-page.xml,language=XML,label={lst:home-page.xml}]{listings/home-page.xml}

Der Binding-Context ist ein JavaScript Objekt welches exklusiv im Page-Context zur Verfügung steht.
Es ist allgemein Best-Practice dieses Objekt in einem eigenen Model zu verwalten.
Das eigentliche Binding wird vom Backendscript~\emph{\nameref{lst:home-page.js}} (Zeilen 8--11) während des ersten Ladens der Seite durchgeführt.

\lstinputlisting[caption=home-model.js,language=JavaScript,label={lst:home-model.js}]{listings/home-model.js}

Das Backendscript ist für das dynamische Verhalten der Seite verantwortlich.
Hier können die Interaktionen der Benutzer beliebig verarbeitet und der Binding-Context bei Bedarf verwaltet werden.

\lstinputlisting[caption=home-page.js,language=JavaScript,label={lst:home-page.js}]{listings/home-page.js}

\subsubsection*{Code-Behind Komponenten}\label{subsubsec:code-behind-komponenten}
Code-Behind Komponenten bieten die Möglichkeit zur Laufzeit dynamisch Grafikelemente dem UI hinzuzufügen.
Komponenten die das Framework bereits zur Verfügung stellt können direkt mit \texttt{new \textless Component\textgreater()} instanziiert werden.
Bei Bedarf können diese Komponenten auch erweitert und mit zusätzlicher Funktionalität ausgestattet werden.

Da der Home-Screen dynamisch in Abhängigkeit der Client-Configuration erstellt werden muss, werden eigene \texttt{MessageTrigger} Komponenten verwendet.
\subsubsection*{Services}\label{subsubsec:services}
In Services werden diejenigen Funktionen ausgelagert, welche nicht direkt im Zusammenhang mit der grafischen Representation stehen.
So z.~B. die REST-Calls zur API.

\clearpage

\subsubsection{Architektur}



\subsubsection{User Interface}
\begin{figure}[h]
    \centering
    \begin{minipage}[b]{0.4\textwidth}
        \includegraphics[width=\textwidth]{graphics/homescreen-mockup}
        \caption{HomeScreen Mockup}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.4\textwidth}
        \includegraphics[width=\textwidth]{graphics/mockup-received}
        \caption{Inbox Mockup}
    \end{minipage}\label{fig:MobileClient-Mocks}
\end{figure}


\clearpage

\input{sections/conceptcloud}

\subsection{Admin UI}\label{subsec:admin-ui}

\clearpage

\subsection{Proof Of Concept}\label{subsec:proof-of-concept}
\subsubsection*{Anforderungen}
\begin{itemize}
    \item Als \textless Sender Rolle\textgreater möchte ich Notifikationen versenden können.
    \item Als \textless Empfänger Rolle\textgreater möchte ich Notifikationen in der Applikation sehen, wenn die Applikation geöffnet ist.
    \item Als \textless Empfänger Rolle\textgreater möchte ich Notifikationen über das OS erhalten, wenn die Applikation minimiert ist.
\end{itemize}
\subsubsection*{Restriktionen}
\begin{itemize}
    \item Nur 1 Client.
    \item Nur 1 fixe Notifikation. Keine Types.
    \item Notifikation wird vom Client gesendet und vom selben Client empfangen.
    \item Keine Authentication oder Authorization.
\end{itemize}
